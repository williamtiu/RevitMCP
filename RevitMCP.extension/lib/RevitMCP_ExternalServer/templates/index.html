<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RevitMCP Chat</title>
    <script defer src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f6f8;
            display: flex;
            height: 100vh;
            overflow: hidden; /* Prevent body scroll */
        }

        #app-container {
            display: flex;
            width: 100%;
            height: 100%;
            /* position: relative; */ /* No longer needed for absolute sidebar */
        }

        #sidebar {
            width: 280px; 
            background-color: #202123; 
            color: #ececec;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            height: 100vh; /* Or 100% if app-container is strictly 100vh */
            overflow-y: auto;
            /* position: absolute; */ /* No longer absolute */
            /* top: 0; */
            /* left: 0; */
            /* z-index: 1100; */
            /* transform: translateX(-100%); */ /* Not using transform for hiding anymore */
            transition: width 0.3s ease, padding-left 0.3s ease, padding-right 0.3s ease; 
            flex-shrink: 0; /* Prevent sidebar from shrinking unintendedly */
        }

        /* State when sidebar is closed */
        #sidebar.sidebar-closed {
            width: 0;
            padding-left: 0;
            padding-right: 0;
            overflow: hidden; /* Hide content when collapsed */
        }

        #sidebar.sidebar-closed h2,
        #sidebar.sidebar-closed ul,
        #sidebar.sidebar-closed .sidebar-actions {
            display: none; /* Ensure content is hidden */
        }

        #sidebar h2 {
            margin-top: 0;
            font-size: 1.2em;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            color: #007bff;
        }

        #sidebar ul {
            list-style-type: none;
            padding: 0;
            margin: 0;
            flex-grow: 1;
        }

        #sidebar li {
            padding: 10px 5px;
            margin-bottom: 8px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #sidebar li:hover {
            background-color: #343541;
        }
        
        #sidebar li.active-chat {
            background-color: #4a4a64;
            font-weight: bold;
        }
        
        .sidebar-actions {
            display: flex;
            gap: 10px; /* Space between new chat and settings */
            margin-top: auto; /* Pushes to the bottom */
        }

        #new-chat-button {
            flex-grow: 1; /* Allow it to take available space */
            background-color: #343541;
            color: #ececec;
            border: 1px solid #555;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
        }
        #new-chat-button:hover {
            background-color: #4a4a64;
        }

        #settings-button {
            background-color: #343541;
            color: #ececec;
            border: 1px solid #555;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.2em; /* Make icon slightly larger */
            line-height: 1; /* Adjust for vertical alignment if needed */
            width: 40px; /* Fixed width for icon button */
            text-align: center;
        }
        #settings-button:hover {
            background-color: #4a4a64;
        }

        #chat-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            background-color: #ffffff;
        }

        #top-bar {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background-color: #f0f0f0; /* Same as old controls, or a new color */
            border-bottom: 1px solid #e0e0e0;
            gap: 10px; /* Space between buttons and controls */
        }

        #top-bar button {
            background-color: transparent;
            border: none;
            font-size: 1.5em; /* Make icons larger */
            padding: 5px;
            cursor: pointer;
            color: #333;
        }
        #top-bar button:hover {
            color: #007bff;
        }

        /* Adjustments for existing #controls if needed, now that it's in a flex container */
        #controls {
            /* padding: 15px; */ /* Padding is now on top-bar */
            /* background-color: #f0f0f0; */ /* Background is now on top-bar */
            /* border-bottom: 1px solid #e0e0e0; */ /* Border is now on top-bar */
            display: flex; /* Keep its own items flexible if necessary */
            gap: 5px; /* Reduced gap if items were too spaced */
            align-items: center;
            /* flex-wrap: wrap; */ /* May not be needed if top-bar handles wrapping or has enough space */
            margin-left: auto; /* Push model selector to the right */
        }
        #controls label, #controls select, #controls input, #controls button {
            /* margin-right: 5px; */ /* Gap handles spacing now */
            font-size: 0.9em;
        }
        #controls input[type="text"], #controls select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        #message-log {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            background-color: #ffffff;
            border-bottom: 1px solid #e0e0e0;
            /* Styles for .message, .user-message, .bot-message will be removed from here */
        }

        /* Markdown specific styles for bot messages */
        .bot-message pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "Courier New", Courier, monospace;
            font-size: 0.9em;
        }
        .bot-message code { /* Inline code */
            background-color: #f0f0f0;
            color: #c7254e;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: "Courier New", Courier, monospace;
        }
        .bot-message h1, .bot-message h2, .bot-message h3 {
            margin-top: 1em;
            margin-bottom: 0.5em;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.3em;
        }
        .bot-message ul, .bot-message ol {
            padding-left: 20px;
        }
        .bot-message blockquote {
            border-left: 4px solid #ccc;
            padding-left: 10px;
            color: #666;
            margin-left: 0;
        }
        .bot-message table {
            border-collapse: collapse;
            margin-bottom: 1em;
            width: auto;
        }
        .bot-message th, .bot-message td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .bot-message th {
            background-color: #f2f2f2;
        }

        #input-area {
            display: flex;
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            background-color: #f8f9fa;
        }

        #message-input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 20px;
            margin-right: 10px;
            font-size: 1em;
        }

        #send-button {
            padding: 10px 20px;
            background-color: #1362bb;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1em;
        }
        #send-button:hover {
            background-color: #164881;
        }
        
        #status {
            padding: 5px 15px;
            background-color: #f0f0f0;
            font-size: 0.8em;
            text-align: center;
            color: #666;
        }

        /* Settings Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; 
            z-index: 1000; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        }

        .modal-content {
            background-color: #fefefe;
            margin: 10% auto; /* 10% from the top and centered */
            padding: 25px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
        }

        .modal-content h2 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .modal-content label {
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .modal-content input[type="password"], .modal-content input[type="text"] {
            width: calc(100% - 22px); /* Full width minus padding and border */
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
        }

        #save-settings-button {
            background-color: #007bff;
            color: white;
        }
        #save-settings-button:hover {
            background-color: #0056b3;
        }

        #cancel-settings-button {
            background-color: #6c757d;
            color: white;
        }
        #cancel-settings-button:hover {
            background-color: #5a6268;
        }

        /* CSS rules for the old #sidebar-toggle-button and its collapsed state are removed or commented */

        /* #sidebar.sidebar-collapsed {
            width: 0;
            padding-left: 0;
            padding-right: 0;
            overflow: visible; 
        } */
        
        /* #sidebar.sidebar-collapsed #sidebar-toggle-button {
            right: auto; 
            left: 0px; 
            border-left: 1px solid #555; 
            border-radius: 6px 0 0 6px; 
        } */

        #sidebar.sidebar-collapsed h2, /* This rule might become obsolete if sidebar uses transform */
        #sidebar.sidebar-collapsed ul,
        #sidebar.sidebar-collapsed .sidebar-actions {
            display: none; /* This is still good if we want to ensure content is hidden if transform fails or for other reasons */
        }

        .chat-item-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%; /* Ensure it takes full width of li */
        }

        .chat-item-title {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-item-options-button {
            background: none;
            border: none;
            color: #ccc;
            font-size: 1.1em;
            padding: 0 5px;
            cursor: pointer;
            margin-left: 5px;
            display: none; /* Hidden by default, shown on li:hover */
        }

        #sidebar li:hover .chat-item-options-button {
            display: inline-block;
        }

        .chat-options-menu {
            position: absolute;
            background-color: #343541; /* Darker than sidebar item */
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1200; /* Above sidebar items */
            min-width: 100px;
            display: none; /* Hidden by default */
        }

        .chat-options-menu button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            text-align: left;
            background: none;
            border: none;
            color: #ececec;
            cursor: pointer;
            font-size: 0.9em;
        }

        .chat-options-menu button:hover {
            background-color: #4a4a64;
        }

        /* Styles for the tool call visual representation in bot messages */
        .tool-call-visual {
            border: 1px solid #007bff; /* Blue border */
        }

    </style>
</head>
<body>
    <div id="app-container">
        <div id="sidebar">
            <h2>Chat History</h2>
            <ul id="chat-history-list">
                <!-- Chat history items will be populated here by JavaScript -->
            </ul>
            <div class="sidebar-actions">
                <button id="settings-button">&#8942;</button> <!-- Settings Icon changed to vertical ellipsis -->
                <button id="test-cases-button" title="Test Cases" style="font-size: 1.2em; width: 40px; text-align: center; background-color: #343541; color: #ececec; border: 1px solid #555; padding: 10px; border-radius: 5px; cursor: pointer;">🧪</button>
            </div>
        </div>
        <div id="chat-area">
            <div id="top-bar">
                <button id="top-bar-toggle-sidebar" title="Toggle Sidebar">☰</button> <!-- New sidebar toggle -->
                <button id="top-bar-new-chat" title="New Chat">+</button> <!-- New new chat button -->
                <div id="controls">
                    <label for="model-selector">Model:</label>
                    <select id="model-selector">
                        <option value="echo_model">Echo Model (Test)</option>
                        <optgroup label="OpenAI">
                            <option value="gpt-4o">GPT-4o</option>
                            <option value="gpt-4o-mini">GPT-4o mini</option>
                            <option value="o3">o3</option>
                            <option value="o3-mini">o3 mini</option>
                        </optgroup>
                        <optgroup label="Anthropic">
                            <option value="claude-4-sonnet">claude-4-sonnet</option>
                            <option value="claude-4-opus">claude-4-opus</option>
                            <option value="claude-3-7-sonnet">claude-3-7-sonnet</option>
                            <option value="claude-3-5-sonnet">claude-3-5-sonnet</option>
                        </optgroup>
                        <optgroup label="Google Gemini">
                            <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
                            <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                        </optgroup>
                        <optgroup label="Ollama">
                            <option value="ollama-mistral">Ollama - Mistral</option>
                            <option value="ollama-llama2">Ollama - Llama2</option>
                            <option value="ollama-codellama">Ollama - CodeLlama</option>
                            <option value="ollama-custom">Ollama - Custom</option>
                        </optgroup>
                    </select>
                    <!-- API Key input removed from here -->
                </div>
            </div>
            <div id="message-log">
                <!-- Messages will be appended here -->
            </div>
            <div id="input-area">
                <input type="text" id="message-input" placeholder="Type your message...">
                <button id="send-button">Send</button>
            </div>
            <div id="status">Ready</div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeSettingsModal()">&times;</span>
            <h2>Settings</h2>
            
            <label for="openai-api-key">OpenAI API Key:</label>
            <input type="password" id="openai-api-key" name="openai-api-key">

            <label for="anthropic-api-key">Anthropic API Key:</label>
            <input type="password" id="anthropic-api-key" name="anthropic-api-key">

            <label for="google-api-key">Google API Key:</label>
            <input type="password" id="google-api-key" name="google-api-key">

            <label for="ollama-server-url">Ollama Server URL:</label>
            <input type="text" id="ollama-server-url" name="ollama-server-url" placeholder="e.g., http://localhost:11434">

            <label for="preferred-model">Preferred Model:</label>
            <select id="preferred-model" name="preferred-model">
                <!-- Options will be populated by JavaScript -->
            </select>
            <button onclick="saveSettings()">Save Settings</button>
            <p id="settings-status"></p>
        </div>
    </div>

    <!-- Test Cases Modal -->
    <div id="test-cases-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeTestCasesModal()">&times;</span>
            <h2>RevitMCP Test Cases</h2>
            <div id="test-cases-list" style="max-height: 400px; overflow-y: auto;">
                <!-- Test cases will be populated here by JavaScript -->
            </div>
            <div class="modal-buttons">
                <button onclick="closeTestCasesModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        const revitTestCases = [
            { id: "test_proj_info", name: "Get Project Info", prompt: "What is the current Revit project name, file path, and Revit version?" },
            { id: "test_list_walls", name: "List All Walls", prompt: "Get all wall elements in the model. Store them." },
            { id: "test_select_stored_walls", name: "Select Stored Walls", prompt: "Select the walls you just listed." },
            { id: "test_list_doors", name: "List Doors on Level 1", prompt: "Find all doors on 'Level 1'. Store them." },
            { id: "test_select_stored_doors_l1", name: "Select Stored Doors (L1)", prompt: "Now, select those doors found on Level 1." },
            { id: "test_filter_windows_param", name: "Filter Windows by Parameter", prompt: "Find all windows with a 'Sill Height' parameter greater than '1000 mm'. Store them."},
            { id: "test_get_properties_window", name: "Get Properties of One Window", prompt: "After finding windows, get the 'Width' and 'Height' parameters for the first window ID found."},
            { id: "test_update_comment_conceptual", name: "Update Comment (Conceptual)", prompt: "Use the planner to create a workflow: 1. Find any three wall elements. 2. Update their 'Comments' parameter to 'RMC Test - Random Comment'. 3. Select these three walls."},
            { id: "test_list_stored", name: "List Stored Elements", prompt: "List all element categories that are currently stored from previous commands." }
        ];

        const messageLog = document.getElementById('message-log');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const modelSelector = document.getElementById('model-selector');
        const statusDiv = document.getElementById('status');
        const chatHistoryList = document.getElementById('chat-history-list');
        const newChatButton = document.getElementById('new-chat-button');

        // Settings Modal elements
        const settingsButton = document.getElementById('settings-button');
        const settingsModal = document.getElementById('settings-modal');
        const closeSettingsModalButton = settingsModal.querySelector('.close-button');
        const openaiApiKeyInput = document.getElementById('openai-api-key');
        const anthropicApiKeyInput = document.getElementById('anthropic-api-key');
        const googleApiKeyInput = document.getElementById('google-api-key');
        const ollamaServerUrlInput = document.getElementById('ollama-server-url'); // Added
        const preferredModelSelect = document.getElementById('preferred-model');
        const settingsStatus = document.getElementById('settings-status');

        // Test Cases Modal elements
        const testCasesModal = document.getElementById('test-cases-modal');
        const testCasesButton = document.getElementById('test-cases-button');
        const testCasesListDiv = document.getElementById('test-cases-list');

        // New top bar buttons
        const topBarToggleSidebarButton = document.getElementById('top-bar-toggle-sidebar');
        const topBarNewChatButton = document.getElementById('top-bar-new-chat');

        let currentConversation = [];
        let allChats = {};
        let activeChatId = null;

        // Wrap dependent initializations in DOMContentLoaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initial load of chats from storage
            loadChatsFromStorage();
            loadApiKeysFromStorage(); // Load API keys on start

            // Sidebar Toggle Functionality
            const sidebar = document.getElementById('sidebar');

            // Load sidebar state from localStorage
            // Default to open (not closed), so isSidebarClosed is true if item is 'true'
            let isSidebarClosed = localStorage.getItem('revitMCP_sidebar_closed') === 'true'; 
            
            function applySidebarState() {
                if (isSidebarClosed) {
                    sidebar.classList.add('sidebar-closed');
                    topBarToggleSidebarButton.textContent = '»'; // Or your preferred "open" icon (e.g., ☰)
                } else {
                    sidebar.classList.remove('sidebar-closed');
                    topBarToggleSidebarButton.textContent = '«'; // Or your preferred "close" icon (e.g., <)
                }
            }
            // Initialize sidebar state: if nothing in localStorage, sidebar should be open (not closed).
            // So, if 'revitMCP_sidebar_closed' is null, isSidebarClosed is false.
            if (localStorage.getItem('revitMCP_sidebar_closed') === null) {
                isSidebarClosed = false; // Default to open
            }
            applySidebarState(); // Apply initial state

            topBarToggleSidebarButton.addEventListener('click', () => {
                isSidebarClosed = !isSidebarClosed; 
                applySidebarState(); 
                localStorage.setItem('revitMCP_sidebar_closed', isSidebarClosed);
            });
            
            // Connect new top-bar new chat button
            topBarNewChatButton.addEventListener('click', startNewChat);

            // Load last selected model
            const savedModel = localStorage.getItem('revitMCPselectedModel');
            if (savedModel) {
                modelSelector.value = savedModel;
            }
        });

        // --- Settings Modal Logic --- (listeners can be set up outside DOMContentLoaded)
        function openSettingsModal() {
            // Load current settings into the modal inputs
            openaiApiKeyInput.value = localStorage.getItem('revitMCP_openai_api_key') || '';
            anthropicApiKeyInput.value = localStorage.getItem('revitMCP_anthropic_api_key') || '';
            googleApiKeyInput.value = localStorage.getItem('revitMCP_google_api_key') || '';
            ollamaServerUrlInput.value = localStorage.getItem('revitMCP_ollama_server_url') || 'http://localhost:11434'; // Added
            
            // Populate the preferred model selector by copying options from the main model selector
            preferredModelSelect.innerHTML = modelSelector.innerHTML;
            // Set the selected value for the preferred model
            const savedPreferredModel = localStorage.getItem('revitMCPselectedModel');
            if (savedPreferredModel) {
                preferredModelSelect.value = savedPreferredModel;
            } else if (modelSelector.options.length > 0) {
                preferredModelSelect.value = modelSelector.options[0].value; // Default to first option of main selector
            }

            settingsModal.style.display = 'block';
            settingsStatus.textContent = '';
        }

        function closeSettingsModal() {
            settingsModal.style.display = 'none';
        }

        function saveSettings() {
            localStorage.setItem('revitMCP_openai_api_key', openaiApiKeyInput.value.trim());
            localStorage.setItem('revitMCP_anthropic_api_key', anthropicApiKeyInput.value.trim());
            localStorage.setItem('revitMCP_google_api_key', googleApiKeyInput.value.trim());
            localStorage.setItem('revitMCP_ollama_server_url', ollamaServerUrlInput.value.trim()); // Added
            localStorage.setItem('revitMCPselectedModel', preferredModelSelect.value);
            
            settingsStatus.textContent = 'Settings saved!';
            // Update the main model selector as well if the preferred model changed
            // populateModelSelector(modelSelector, true); // No longer needed, main selector is static
            modelSelector.value = preferredModelSelect.value;
            
            setTimeout(() => {
                closeSettingsModal();
            }, 1000);
        }

        // Attach event listeners for settings modal
        if (settingsButton) {
            settingsButton.addEventListener('click', openSettingsModal);
        }
        if (closeSettingsModalButton) {
            closeSettingsModalButton.addEventListener('click', closeSettingsModal);
        }
        // saveSettings is called by button onclick directly in HTML

        // --- Chat History Management --- (functions defined, called by DOMContentLoaded or events)
        function generateChatId() {
            return 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function saveCurrentChat() {
            if (activeChatId && currentConversation.length > 0) {
                allChats[activeChatId] = [...currentConversation];
                localStorage.setItem('allRevitMCPChats', JSON.stringify(allChats));
                renderChatHistoryList();
            }
        }
        
        function getChatTitle(conversationOrChatObject) {
            // Check if it's the full chat object which might have metadata.customTitle
            if (conversationOrChatObject && typeof conversationOrChatObject === 'object' && !Array.isArray(conversationOrChatObject)) {
                if (conversationOrChatObject.metadata && conversationOrChatObject.metadata.customTitle) {
                    return conversationOrChatObject.metadata.customTitle;
                }
                // If no customTitle, fall back to deriving from messages (assuming it has a messages array)
                // This part needs care: what if conversationOrChatObject is the array directly?
                // Let's assume the argument to getChatTitle is always the array of messages from allChats[chatId]
                // OR the chat object from allChats[chatId] which would be an array of messages (current structure)
                // OR the chat object which is an object containing messages and metadata (new structure)

                // To handle both current (array) and potential future (object with .messages):
                let messages = Array.isArray(conversationOrChatObject) ? conversationOrChatObject : conversationOrChatObject.messages;
                if (!messages) messages = []; // Fallback if structure is unexpected

                const firstUserMessage = messages.find(msg => msg.role === 'user');
                if (firstUserMessage && firstUserMessage.content) {
                    return firstUserMessage.content.substring(0, 30) + (firstUserMessage.content.length > 30 ? '...' : '');
                }
                return "New Chat"; // Default if no user message or empty
            }
            // Fallback for old calls or direct message array
            if (Array.isArray(conversationOrChatObject) && conversationOrChatObject.length === 0) return "New Chat";
            if (Array.isArray(conversationOrChatObject)) {
                const firstUserMessage = conversationOrChatObject.find(msg => msg.role === 'user');
                 if (firstUserMessage && firstUserMessage.content) {
                    return firstUserMessage.content.substring(0, 30) + (firstUserMessage.content.length > 30 ? '...' : '');
                }
            }
            
            // Fallback for empty/newly created chats before any messages if not handled above
            const chatKey = Object.keys(allChats).find(key => allChats[key] === conversationOrChatObject);
            const chatIndex = chatKey ? Object.keys(allChats).indexOf(chatKey) : -1;
            return "Chat " + (chatIndex >= 0 ? chatIndex + 1 : Object.keys(allChats).length +1) ;
        }

        function renderChatHistoryList() {
            chatHistoryList.innerHTML = '';
            const sortedChatIds = Object.keys(allChats).sort((a,b) => {
                 return parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]);
            });

            sortedChatIds.forEach(chatId => {
                const chat = allChats[chatId];
                const listItem = document.createElement('li');
                
                const container = document.createElement('div');
                container.classList.add('chat-item-container');

                const titleSpan = document.createElement('span');
                titleSpan.classList.add('chat-item-title');
                titleSpan.textContent = getChatTitle(chat); // Use existing function for now
                titleSpan.title = getChatTitle(chat); // Full title on hover

                const optionsButton = document.createElement('button');
                optionsButton.classList.add('chat-item-options-button');
                optionsButton.innerHTML = '&#8942;'; // Vertical ellipsis HTML entity
                optionsButton.title = 'More options';
                optionsButton.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent li click event
                    toggleChatOptionsMenu(event.currentTarget, chatId);
                });

                container.appendChild(titleSpan);
                container.appendChild(optionsButton);
                listItem.appendChild(container);

                listItem.dataset.chatId = chatId;
                if (chatId === activeChatId) {
                    listItem.classList.add('active-chat');
                }
                listItem.addEventListener('click', () => loadChat(chatId));
                chatHistoryList.appendChild(listItem);
            });
        }

        function toggleChatOptionsMenu(buttonElement, chatId) {
            closeAllOptionMenus(); // Close any other open menus
            let menu = document.getElementById('chat-options-menu-' + chatId);
            if (!menu) {
                menu = createChatOptionsMenu(chatId);
                // Position menu near the button
                const rect = buttonElement.getBoundingClientRect();
                document.body.appendChild(menu); // Append to body to avoid overflow issues
                menu.style.top = (rect.bottom + window.scrollY) + 'px';
                menu.style.left = (rect.left + window.scrollX - menu.offsetWidth + rect.width) + 'px';
            }
            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
        }

        function createChatOptionsMenu(chatId) {
            const menu = document.createElement('div');
            menu.id = 'chat-options-menu-' + chatId;
            menu.classList.add('chat-options-menu');

            const renameButton = document.createElement('button');
            renameButton.textContent = 'Rename';
            renameButton.addEventListener('click', () => {
                renameChat(chatId);
                menu.style.display = 'none';
            });

            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.addEventListener('click', () => {
                deleteChat(chatId);
                menu.style.display = 'none';
            });

            menu.appendChild(renameButton);
            menu.appendChild(deleteButton);
            return menu;
        }

        function closeAllOptionMenus() {
            document.querySelectorAll('.chat-options-menu').forEach(menu => {
                menu.style.display = 'none';
            });
        }
        
        // Add a global click listener to close menus if clicked outside
        document.addEventListener('click', function(event) {
            const openMenus = document.querySelectorAll('.chat-options-menu');
            let clickedInsideMenu = false;
            openMenus.forEach(menu => {
                if (menu.contains(event.target)) {
                    clickedInsideMenu = true;
                }
            });
            const clickedOnOptionsButton = event.target.closest('.chat-item-options-button');

            if (!clickedInsideMenu && !clickedOnOptionsButton) {
                closeAllOptionMenus();
            }
        });

        function loadChat(chatId) {
            if (allChats[chatId]) {
                saveCurrentChat();
                activeChatId = chatId;
                currentConversation = [...allChats[chatId]];
                messageLog.innerHTML = '';
                currentConversation.forEach(msg => displayMessage(msg.role, msg.content, false));
                renderChatHistoryList();
                statusDiv.textContent = `Loaded chat: ${getChatTitle(currentConversation)}`;
            }
        }

        function startNewChat() {
            saveCurrentChat();
            activeChatId = generateChatId();
            currentConversation = [];
            messageLog.innerHTML = '';
            allChats[activeChatId] = [];
            renderChatHistoryList();
            statusDiv.textContent = 'New chat started.';
            messageInput.focus();
        }
        
        function loadChatsFromStorage() {
            const storedChats = localStorage.getItem('allRevitMCPChats');
            if (storedChats) {
                allChats = JSON.parse(storedChats);
                const chatIds = Object.keys(allChats);
                if (chatIds.length > 0) {
                    const mostRecentChatId = chatIds.sort((a,b) => parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]))[0];
                    loadChat(mostRecentChatId || chatIds[0]);
                } else {
                    startNewChat();
                }
            } else {
                startNewChat();
            }
            renderChatHistoryList(); // This is fine here, as DOM elements exist by the time it's called
        }

        function loadApiKeysFromStorage() {
            // Implementation of loadApiKeysFromStorage function
        }

        // --- Message Display & Sending --- (functions defined, called by events)
        function displayMessage(role, message, shouldSave = true) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', role === 'user' ? 'user-message' : 'bot-message');
            
            if (role === 'bot') {
                if (typeof marked !== 'undefined' && marked && typeof marked.parse === 'function') {
                    messageDiv.innerHTML = marked.parse(message || " ");
                } else {
                    console.warn("'marked' library is not available. Displaying raw message. Check CDN link or network.");
                    messageDiv.textContent = message; // Fallback to raw text
                }
            } else {
                messageDiv.textContent = message;
            }
            
            messageLog.appendChild(messageDiv);
            messageLog.scrollTop = messageLog.scrollHeight;

            if (shouldSave) {
                currentConversation.push({ role: role, content: message });
                saveCurrentChat();
            }
        }

        async function sendMessage() {
            const messageText = messageInput.value.trim();
            if (!messageText) return;

            displayMessage('user', messageText);
            
            const selectedModelValue = modelSelector.value;
            let apiKeyToUse = getApiKeyForModel(selectedModelValue); // Use existing helper

            // No longer need special parsing for /get_view, LLM handles it.
            
            const payload = {
                conversation: [...currentConversation], // currentConversation includes the new user message from displayMessage
                model: selectedModelValue,
                apiKey: apiKeyToUse // This will be the specific key for the selected model's provider
            };
            
            messageInput.value = '';
            statusDiv.textContent = 'Sending...';

            try {
                const response = await fetch('/chat_api', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                // Display the main text reply from the LLM
                if (data.reply) {
                    displayMessage('bot', data.reply);
                }

                // Check if there's an image to display alongside the text reply
                if (data.image_output && data.image_output.status === 'success') {
                    displayImageOutput(data.image_output.image_data, data.image_output.content_type);
                } else if (data.image_output && data.image_output.status === 'error') {
                    // Optionally display a specific error if the image tool failed but LLM still replied
                    console.warn("Image tool failed:", data.image_output.message);
                    // You could display a small error message here too if desired, e.g.:
                    // displayMessage('bot', `(Note: Could not retrieve image - ${data.image_output.message})`, false);
                }

                // Handle other tool_output or tool_error types if they are sent outside of image_output
                // (This part might be less relevant if all tool interactions are now summarized by the LLM in data.reply)
                if (data.reply_type === 'tool_output' && (!data.image_output || data.image_output.tool_name !== 'get_revit_view')) {
                    displayToolOutput(data.data, data.tool_name || 'Tool'); 
                } else if (data.reply_type === 'tool_error') {
                    // This might be redundant if LLM incorporates tool errors into its main reply
                    displayMessage('bot', `Tool Error (${data.tool_name || 'Unknown Tool'}): ${data.error || 'Unknown error'}`);
                }

                statusDiv.textContent = 'Ready';

            } catch (error) {
                console.error('Error sending message:', error);
                displayMessage('bot', `Error: ${error.message}`);
                statusDiv.textContent = `Error: ${error.message.substring(0,100)}`;
            }
        }

        function displayImageOutput(imageData, contentType) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'bot-message', 'image-output-message');

            const img = document.createElement('img');
            img.src = `data:${contentType};base64,${imageData}`;
            img.alt = "Revit View Export";
            img.style.maxWidth = '100%';
            img.style.maxHeight = '500px'; // Limit image height
            img.style.borderRadius = '8px';

            messageDiv.appendChild(img);
            messageLog.appendChild(messageDiv);
            messageLog.scrollTop = messageLog.scrollHeight;

            // Optionally save a placeholder or info about the image to conversation history
            // currentConversation.push({ role: 'assistant', type: 'image_response', tool_name: 'get_revit_view', content: `Displayed image: ${contentType}` });
            // saveCurrentChat();
        }

        function displayToolOutput(toolData, toolName) { // Modified to accept toolName
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'bot-message', 'tool-output-message');
            messageDiv.textContent = `Tool Output (${toolName || 'Tool'}): ${toolData || 'No output'}`;
            messageLog.appendChild(messageDiv);
            messageLog.scrollTop = messageLog.scrollHeight;
        }

        // Event listeners for UI elements (can be set up outside DOMContentLoaded as elements exist)
        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        // newChatButton.addEventListener('click', startNewChat); // Old button listener removed
        
        // Event listener for model selector (can be outside DOMContentLoaded)
        modelSelector.addEventListener('change', () => {
            localStorage.setItem('revitMCPselectedModel', modelSelector.value);
        });

        function renameChat(chatId) {
            const chatToRename = allChats[chatId];
            if (!chatToRename) return;

            const currentTitle = getChatTitle(chatToRename);
            const newTitle = prompt("Enter new name for chat:", currentTitle);

            if (newTitle && newTitle.trim() !== '' && newTitle !== currentTitle) {
                // If we want to store custom titles, we need to modify the chat object structure.
                // For now, let's assume getChatTitle is sufficient or we add a 'customTitle' field.
                if (!allChats[chatId].metadata) {
                    allChats[chatId].metadata = {};
                }
                allChats[chatId].metadata.customTitle = newTitle.trim();
                
                // Update localStorage immediately
                localStorage.setItem('allRevitMCPChats', JSON.stringify(allChats));
                renderChatHistoryList(); // Re-render to show new title
                if (chatId === activeChatId) {
                    statusDiv.textContent = `Chat renamed to: ${newTitle.trim()}`;
                }
            }
        }

        function deleteChat(chatId) {
            const chatToDelete = allChats[chatId];
            if (!chatToDelete) return;

            const chatTitle = getChatTitle(chatToDelete);
            if (confirm("Are you sure you want to delete chat: '" + chatTitle + "'?")) {
                delete allChats[chatId];
                localStorage.setItem('allRevitMCPChats', JSON.stringify(allChats));
                
                if (activeChatId === chatId) {
                    activeChatId = null; // Clear active chat
                    // Find the most recent remaining chat to load, or start new if none left
                    const remainingChatIds = Object.keys(allChats).sort((a,b) => parseInt(b.split('_')[1]) - parseInt(a.split('_')[1]));
                    if (remainingChatIds.length > 0) {
                        loadChat(remainingChatIds[0]);
                    } else {
                        startNewChat();
                    }
                } else {
                    renderChatHistoryList(); // Just re-render if a non-active chat was deleted
                }
                statusDiv.textContent = `Chat '${chatTitle}' deleted.`;
            }
        }

        function getApiKeyForModel(modelName) {
            if (!modelName) return ''; // Should not happen if a model is always selected

            if (modelName.startsWith('gpt-') || modelName.startsWith('o3-')) { // Adjusted for o3 prefix
                return localStorage.getItem('revitMCP_openai_api_key') || '';
            } else if (modelName.startsWith('claude-')) {
                return localStorage.getItem('revitMCP_anthropic_api_key') || '';
            } else if (modelName.startsWith('gemini-')) {
                return localStorage.getItem('revitMCP_google_api_key') || '';
            } else if (modelName.startsWith('ollama-')) {
                return localStorage.getItem('revitMCP_ollama_server_url') || 'http://localhost:11434'; // Added
            }
            // For 'echo_model' or any other model not matching known prefixes, no API key is needed by the backend.
            return ''; 
        }

        // --- Test Cases Modal Logic ---
        function openTestCasesModal() {
            testCasesListDiv.innerHTML = ''; // Clear previous list
            revitTestCases.forEach(tc => {
                const button = document.createElement('button');
                button.textContent = tc.name;
                button.title = tc.prompt; // Show full prompt on hover
                button.style.display = 'block';
                button.style.width = '100%';
                button.style.marginBottom = '8px';
                button.style.padding = '10px';
                button.style.textAlign = 'left';
                button.style.backgroundColor = '#f0f0f0';
                button.style.border = '1px solid #ccc';
                button.style.borderRadius = '4px';
                button.style.cursor = 'pointer';
                button.onclick = () => {
                    executeTestCase(tc.prompt);
                    closeTestCasesModal();
                };
                testCasesListDiv.appendChild(button);
            });
            testCasesModal.style.display = 'block';
        }

        function closeTestCasesModal() {
            testCasesModal.style.display = 'none';
        }

        function executeTestCase(promptText) {
            messageInput.value = promptText; // Put prompt in input field
            sendMessage(); // Send it
        }

        // Attach event listeners for test cases modal
        if (testCasesButton) testCasesButton.addEventListener('click', openTestCasesModal);
        // The close button in the modal uses an inline onclick for closeTestCasesModal().

    </script>
</body>
</html> 